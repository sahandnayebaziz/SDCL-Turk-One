<template name="tool">

	<div class="container-fluid container-tool">
		<div class="row">
			<div class="col-md-12 col-lg-4 bottom-buffer-50 md-fixed">
				{{#with decisionPoint}}
					{{>decisionPointInformationPanel}}
				{{/with}}
			</div>
			<div class="col-md-12 col-lg-8 col-lg-offset-4 bottom-buffer-100" data-intro="These are the 5 different canvases and text boxes where you can design your solutions in. You can sketch your solutions in the white boxes and name and describe them below the box.
			Do not forget to provide a name and explanation for all your solutions."
                 data-position="left">
				<div class="row">
					<div class="col-lg-1 col-md-12" >
						<div id="toolbarContainer" class="md-fixed" data-intro="These are your sketching tools. Click on the question mark to toggle on the tips to see what each button does." data-position="left">
							<span class="buttonToolbar buttonColor" id="buttonBlack" data-color="#414141"></span>

							<!--<span class="buttonColor" id="buttonWhite" data-color="#FFFFFF"></span>-->
							<span class="buttonToolbar deselectedTool buttonColor" id="buttonBlue" data-color="#80D4FC"></span>

							<span class="buttonToolbar deselectedTool buttonColor" id="buttonGreen" data-color="#A1F5AA"
							      data-placement="left" href="#" data-trigger="manual" data-toggle="tooltip"
							      title="Use these buttons to select the colour of your brush"></span>

							<span class="buttonToolbar deselectedTool buttonColor" id="buttonRed" data-color="#F78479"></span>

							<span class="buttonToolbar deselectedTool buttonColor" id="buttonYellow" data-color="#FBDE9E"></span>

							<img src="/type.png" class="buttonToolbar deselectedTool" id="buttonText" data-placement="right" href="#"
							     data-trigger="manual" data-toggle="tooltip" title="Add text to your sketch: click anywhere on the canvas to add, then click on the text to edit.">

							<span class="buttonToolbar deselectedTool" id="buttonMove" data-placement="left" href="#"
							      data-trigger="manual" data-toggle="tooltip"
							      title="With this tool you can move, resize or rotate every object on your canvas"></span>

							<span class="buttonToolbar deselectedTool" id="buttonEraser" data-placement="right" href="#"
							      data-trigger="manual" data-toggle="tooltip" title="Eraser"></span>

							<img src="/un-do.png" class="buttonToolbar deselectedTool buttonHistory" id="buttonUndo"
							     data-placement="left" href="#" data-trigger="manual" data-toggle="tooltip" title="Undo">

							<img src="/re-do.png" class="buttonToolbar deselectedTool buttonHistory" id="buttonRedo"
							     data-placement="right" href="#" data-trigger="manual" data-toggle="tooltip" title="Redo">

                            <span class="buttonToolbar deselectedTool" id="toolbarTips" data-placement="left" href="#"
                                  data-trigger="manual" data-toggle="tooltip" title="tooltips on/off">?
                            </span>
						</div>
					</div>

					<style>
						@media screen and (max-width: 62em) {
							#toolbarContainer {
								position: fixed;
								bottom: 50px;
								left: 50%;
								margin-left: -200px;
								display: block;
								min-width: 340px;
								height: 46px;
								padding: 10px 9px 9px 17px;
								background: #CECECE;
								box-shadow: 0px 16px 32px 0px rgba(0, 0, 0, 0.24);
								border-radius: 6px;
								z-index: 2;
							}

							.buttonToolbar {
								display: block;
								float: left;
								clear: none;
								margin: 0px 8px 0px 0px;
								height: auto;
								width: 25px;
							}

							#buttonText {
								margin-left: 24px !IMPORTANT;
							}

							#buttonEraser {
								margin-right: 24px !IMPORTANT;
							}

							#buttonRedo, #buttonUndo {
								margin-top: 5px;
							}
						}

						@media screen and (min-width: 62em) {
							#toolbarContainer {
								margin-right: 15px;
								margin-top: 100px;
								background: #CECECE;
								box-shadow: 0px 16px 32px 0px rgba(0, 0, 0, 0.14);
								border-radius: 6px;
								padding-top: 17px;
								padding-bottom: 9px;
								min-width: 50px;
							}

							.buttonToolbar {
								height: auto;
								width: 25px;
								display: block;
								margin-left: auto;
								margin-right: auto;
								margin-bottom: 8px;
							}

							#buttonText {
								margin-top: 24px;
							}

							#buttonMove {
								background-image: url("/controls.png");
								height: 28px;
								width: 28px;
							}

							#buttonEraser {
								background-image: url("/eraser.png");
								height: 25px;
								margin-bottom: 24px;
							}
						}

						.buttonHistory {
							padding-bottom: 3px;
							padding-top: 3px;
						}

						.deselectedTool {
							opacity: 0.4;
						}

						.deselectedTool:hover {
							opacity: 0.8;
						}

						.buttonColor {
							border-radius: 50px;
							height: 25px;
						}

						#buttonBlack {
							background: #414141;
							border: 3px solid #000000;
						}

						#buttonWhite {
							background: #FFFFFF;
							border: 3px solid #BDBDBD;
						}

						#buttonBlue {
							background: #80D4FC;
							border: 3px solid #4B95B4;
						}

						#buttonGreen {
							background: #A1F5AA;
							border: 3px solid #6AB373;
						}

						#buttonRed {
							background: #F78479;
							border: 3px solid #C76A61;
						}

						#buttonYellow {
							background: #FBDE9E;
							border: 3px solid #E9BB35;
						}

						#buttonMove {
							background-image: url("/controls.png");
							height: 28px;
							width: 28px;
						}

						#buttonEraser {
							background-image: url("/eraser.png");
							height: 25px;
						}

						#buttonText {
							height: 25px;
						}

						.selectedTool {
							opacity: 1 !IMPORTANT;
						}

                        #toolbarTips {
                            text-align: center;
                            font-size: 20pt;
                            height: 28px;
                            width: 28px;
                        }

                         .tooltip-inner {
                             border: solid 1px #000000;
                             background-color: #ededed;
                             color: #000000;
                             max-width: 200px;
                             /* If max-width does not work, try using width instead */
                             /*width: 350px;*/
                         }

					</style>
					<script>
						// stopwatch class
						/* Javascript Stopwatch class
						/* http://www.seph.dk
            /*
            /* Copyright 2009 Seph soliman
            /* Released under the MIT license (do whatever you want - just leave my name on it)
						/* http://opensource.org/licenses/MIT
            */

						// * Stopwatch class
						var Stopwatch = function (listener, resolution) {
							this.startTime = 0;
							this.stopTime = 0;
							this.totalElapsed = 0; // * elapsed number of ms in total
							this.started = false;
							this.listener = (listener != undefined ? listener : null); // * function to receive onTick events
							this.tickResolution = (resolution != undefined ? resolution : 500); // * how long between each tick in milliseconds
							this.tickInterval = null;

							// * pretty static vars
							this.onehour = 1000 * 60 * 60;
							this.onemin = 1000 * 60;
							this.onesec = 1000;
						};
						Stopwatch.prototype.start = function () {
							var delegate = function (that, method) {
								return function () {
									return method.call(that)
								}
							};
							if (!this.started) {
								this.startTime = new Date().getTime();
								this.stopTime = 0;
								this.started = true;
								this.tickInterval = setInterval(delegate(this, this.onTick), this.tickResolution);
							}
						};
						Stopwatch.prototype.stop = function () {
							if (this.started) {
								this.stopTime = new Date().getTime();
								this.started = false;
								var elapsed = this.stopTime - this.startTime;
								this.totalElapsed += elapsed;
								if (this.tickInterval != null)
									clearInterval(this.tickInterval);
							}
							return this.getElapsed();
						};
						Stopwatch.prototype.reset = function () {
							this.totalElapsed = 0;
							// * if watch is running, reset it to current time
							this.startTime = new Date().getTime();
							this.stopTime = this.startTime;
						};
						Stopwatch.prototype.restart = function () {
							this.stop();
							this.reset();
							this.start();
						};
						Stopwatch.prototype.getElapsed = function () {
							// * if watch is stopped, use that date, else use now
							var elapsed = 0;
							if (this.started)
								elapsed = new Date().getTime() - this.startTime;
							elapsed += this.totalElapsed;

							var hours = parseInt(elapsed / this.onehour);
							elapsed %= this.onehour;
							var mins = parseInt(elapsed / this.onemin);
							elapsed %= this.onemin;
							var secs = parseInt(elapsed / this.onesec);
							var ms = elapsed % this.onesec;

							return {
								hours: hours,
								minutes: mins,
								seconds: secs,
								milliseconds: ms
							};
						};
						Stopwatch.prototype.setElapsed = function (hours, mins, secs) {
							this.reset();
							this.totalElapsed = 0;
							this.totalElapsed += hours * this.onehour;
							this.totalElapsed += mins * this.onemin;
							this.totalElapsed += secs * this.onesec;
							this.totalElapsed = Math.max(this.totalElapsed, 0); // * No negative numbers
						};
						Stopwatch.prototype.toString = function () {
							var zpad = function (no, digits) {
								no = no.toString();
								while (no.length < digits)
									no = '0' + no;
								return no;
							};
							var e = this.getElapsed();
							return zpad(e.hours, 2) + ":" + zpad(e.minutes, 2) + ":" + zpad(e.seconds, 2);
						};
						Stopwatch.prototype.setListener = function (listener) {
							this.listener = listener;
						};
						// * triggered every <resolution> ms
						Stopwatch.prototype.onTick = function () {
							if (this.listener != null) {
								this.listener(this);
							}
						};

						// initialize stopwatch arrays
						interactionStopwatches = [];
						locationStopwatches = [];

						// functions that operate on stopwatches in those arrays
						function resetInteractionTimers() {
							$.each(interactionStopwatches, function () {
								this.reset();
							});
						}
						function resetLocationTimers() {
							$.each(locationStopwatches, function () {
								this.reset();
							});
						}
						function activateLocationTimers() {
							$.each(locationStopwatches, function () {
								this.start();
							});
						}

						// stopwatch running for canvas with focus
						stopwatchWithFocus = null;

						// stopwatch running for total time on tools page
						pageStopwatch = new Stopwatch();
						locationStopwatches.push(pageStopwatch);
						pageStopwatch.start();

						// initialize idle timers
						idleTime = 0;
						var idleInterval = setInterval(timerIncrement, 1000); // every second
						$(this).mousemove(function (e) {
							idleTime = 0;
						}); // reset the timer
						$(this).keypress(function (e) {
							idleTime = 0;
						});  // reset the timer
						function timerIncrement() {
							idleTime = idleTime + 1;
							if (idleTime > 10) { // every ten seconds
								resetInteractionTimers(); // reset timers
								resetLocationTimers();
							} else {
								activateLocationTimers();
							}
						} 

						// set up for canvases
						// setting the default number of canvases to show
						Session.set("numberOfCanvasesToShow", 5);

						// this array will hold references to each Fabric canvas instance, and is looped through in the below toolbar
						// actions to 'broadcast' the toolbar selects across the canvases
						canvases = [];

						// focusedCanvas
						canvasWithFocus = null;

						// used for maintaing sanity while drawing straight or free-form lines
						isDrawing = false;

						// state object for undo/redo stacks
						canvasHistory = {};

						// Set Black as default color in toolbar (set for each canvas at initialization in tool.html
						Session.set("currentColor", "#414141");
						$("#buttonBlack").addClass("selectedTool");

						// setting toolbar active tool
						function setSelectedTool(tool) {
							$(".selectedTool").removeClass("selectedTool").addClass("deselectedTool");
							$(tool).addClass("selectedTool");

							if ($(tool).attr("id") != "buttonEraser") {
								disableEraser();
							}
						}

						// toolbar color clicked
						$(".buttonColor").click(function () {
							setSelectedTool(this);
							var colorChosen = this.getAttribute("data-color");

							Session.set("currentColor", colorChosen);
							$.each(canvases, function () {
								this.freeDrawingBrush.color = colorChosen;
								this.isDrawingMode = true;
							});

                            ga('send', {
                                hitType: 'event',
                                eventCategory: 'Toolbar',
                                eventAction: 'Selecting a color',
                                eventLabel: Session.get("ticket")
                            });

						});

						// toolbar eraser clicked
						$("#buttonEraser").click(function () {
							setSelectedTool(this);
							enableEraser();

                            ga('send', {
                                hitType: 'event',
                                eventCategory: 'Toolbar',
                                eventAction: 'Eraser',
                                eventLabel: Session.get("ticket")
                            });
						});
						function disableEraser() {

							$.each(canvases, function () {
								this.off("mouse:down");
							});
						}
						function enableEraser() {
							$.each(canvases, function () {
								var canvas = this;

								canvas.isDrawingMode = false;
								canvas.on("mouse:down", function (e) {
									if (this.getActiveGroup()) {
										recordingStates = false;
										canvas.getActiveGroup().forEachObject(function (a) {
											canvas.remove(a);
										});
										canvas.discardActiveGroup();
										recordingStates = true;
									} else {
										canvas.remove(canvas.getActiveObject());
									}
									canvas.renderAll();
								});
							});
						}

						// toolbar move controls clicked
						$("#buttonMove").click(function () {
							setSelectedTool(this);

							$.each(canvases, function () {
								this.isDrawingMode = false;
							})

                            ga('send', {
                                hitType: 'event',
                                eventCategory: 'Toolbar',
                                eventAction: 'Move Controls',
                                eventLabel: Session.get("ticket")
                            });
						});

						// text button clicked
						$("#buttonText").click(function () {

							setSelectedTool(this);
							$.each(canvases, function () {
								this.isDrawingMode = false;
							});

							canvasWithFocus.on("mouse:down", function (e) {
								var pointer = canvasWithFocus.getPointer(event.e);

								canvasWithFocus.add(new fabric.IText('Enter Text', {
									fontFamily: 'times black',
									left: pointer.x,
									top: pointer.y,
									fontSize: 16
								}));

								var textObject = canvasWithFocus.item(canvasWithFocus.getObjects().length - 1);
								canvasWithFocus.setActiveObject(textObject);

								//textObject.enterEditing(); causing the window to scroll is sortof a bug of fabricjs

								textObject.selectAll();
								$.each(canvases, function () {
									this.off("mouse:down");
								});

								setSelectedTool("#buttonMove");
							});

                            ga('send', {
                                hitType: 'event',
                                eventCategory: 'Toolbar',
                                eventAction: 'Text',
                                eventLabel: Session.get("ticket")
                            });
						});

						// UNDO AND REDO
						$("#buttonUndo").click(function () {

							var index = canvasWithFocus.CDIndex;
							var back = canvasHistory[index].backStates;

							if (back.length > 1) {
								canvasHistory[index].recording = false;
								var fromState = back.pop();
								canvasHistory[index].forwardStates.push(fromState);
								var toState = back[back.length - 1];
								canvasWithFocus.loadFromJSON(toState);
								canvasWithFocus.renderAll();
								canvasHistory[index].recording = true;
							}

                            ga('send', {
                                hitType: 'event',
                                eventCategory: 'Toolbar',
                                eventAction: 'Undo',
                                eventLabel: Session.get("ticket")
                            });
						});
						$("#buttonRedo").click(function () {
							var index = canvasWithFocus.CDIndex;
							var forward = canvasHistory[index].forwardStates;

							if (forward.length > 0) {
								canvasHistory[index].recording = false;
								var toState = forward.pop();
								canvasHistory[index].backStates.push(toState);

								canvasWithFocus.loadFromJSON(toState);
								canvasWithFocus.renderAll();
								canvasHistory[index].recording = true;
							}
                            ga('send', {
                                hitType: 'event',
                                eventCategory: 'Toolbar',
                                eventAction: 'Redo',
                                eventLabel: Session.get("ticket")
                            });
						});

                        // tooltips in the toolbar
                        $("#toolbarTips").click(function () {

                            $('[data-toggle="tooltip"]').tooltip('toggle');
                            console.log("pressed the fucking toggle button bitch!");

                            //google analytics
                            ga('send', {
                                hitType: 'event',
                                eventCategory: 'Button',
                                eventAction: 'Tips toggle',
                                eventLabel: Session.get("ticket")
                            });
                        });


						// drawing straight lines when pressing shift
						Mousetrap.bind('shift', function () {

							var line, isDown;

							canvasWithFocus.isDrawingMode = false;
							canvasWithFocus.selection = false;
							canvasWithFocus.forEachObject(function (o) {
								o.selectable = false;
							});

							canvasWithFocus.on('mouse:down', function (o) {
								isDown = true;
								isDrawing = true;
								var pointer = canvasWithFocus.getPointer(o.e);
								var points = [pointer.x, pointer.y, pointer.x, pointer.y];
								line = new fabric.Line(points, {
									strokeWidth: 5,
									fill: 'black',
									stroke: 'black',
									originX: 'center',
									originY: 'center',
								});
								canvasWithFocus.add(line);
							});

							canvasWithFocus.on('mouse:move', function (o) {
								if (!isDown) return;
								var pointer = canvasWithFocus.getPointer(o.e);
								line.set({x2: pointer.x, y2: pointer.y});
								canvasWithFocus.renderAll();
								line.selectable = true;
							});

							canvasWithFocus.on('mouse:up', function (o) {
								isDown = false;
								isDrawing = false;
								//canvasWithFocus.remove(canvasWithFocus.item(canvasWithFocus.getObjects().length - 1));
							});
						}, 'keydown');
						Mousetrap.bind('shift', function () {
							if (!isDrawing) {
								c = canvasWithFocus;
								c.off('mouse:down');
								c.off('mouse:move');
								c.off('mouse:up');

								c.isDrawingMode = false;
								c.selection = true;
								c.forEachObject(function (o) {
									o.selectable = true;
								});
							}
						}, 'keyup');


						// guessing focus
						function findFocus() {

							var scrollPosition = $(window).scrollTop();
							var focusDistance = 9999;
							var focusGuess = null;
							var focusGuessIndex = 0;

							$.each($(".canvasContainer"), function () {
								var positionAtTopOfCanvas = $(this).offset().top;
								var distanceFromScrollPosition = Math.abs(scrollPosition - positionAtTopOfCanvas);
								if ((scrollPosition < positionAtTopOfCanvas + 250) && (distanceFromScrollPosition < focusDistance)) {
									focusDistance = distanceFromScrollPosition;
									focusGuess = this;
								}
							});

							$.each($(".canvasContainer"), function () {
								if (this == focusGuess) {
									$(this).removeClass("unfocusedCanvas");
									$(this).addClass("focusedCanvas");
									focusGuessIndex = parseInt($(this).attr("data-CDIndex"));
								} else {
									$(this).removeClass("focusedCanvas");
									$(this).addClass("unfocusedCanvas");
								}
							});

							$.each(canvases, function () {
								if (this.CDIndex == focusGuessIndex) {
									canvasWithFocus = this;
								}
							});

							$.each(interactionStopwatches, function () {
								if (this.identifier == focusGuessIndex) {
									this.start();
									stopwatchWithFocus = this;
								} else {
									this.stop();
									this.reset();
								}
							});
						}

						// attach focus guessing to window scrolling
						$(window).scroll(findFocus);

						// provide method for forcing focus
						forceFocus = function (index) {

							$.each($(".canvasContainer"), function () {
								if (parseInt($(this).attr("data-cdindex")) == index) {
									$(this).removeClass("unfocusedCanvas");
									$(this).addClass("focusedCanvas");
								} else {
									$(this).removeClass("focusedCanvas");
									$(this).addClass("unfocusedCanvas");
								}
							});

							$.each(canvases, function () {
								if (this.CDIndex == index) {
									canvasWithFocus = this;
								}

							});

							$.each(interactionStopwatches, function () {
								if (this.identifier == index) {
									this.start();
									stopwatchWithFocus = this;
								} else {
									this.stop();
								}
							});

						};

						$("#col-sketch").on("mousedown", ".canvasContainer", function () {
							var index = parseInt($(this).attr("data-cdindex"));
							forceFocus(index);
						});

						// create persistent objects in database for these sketches
						function createPersistSelf(canvasNumber) {
							if (Session.get("insertedSolutionFor" + Session.get("ticket") + canvasNumber)) {

							} else {
								Solutions.insert({
									workerId: Session.get("ticket"),
									createdAt: new Date(),
									dateUpdated: new Date(),
									canvasNumber: canvasNumber,
									status: "pending"
								}, function (error, id) {
									Session.setPersistent("objectId" + Session.get("ticket") + canvasNumber, id);
									Session.setPersistent("insertedSolutionFor" + Session.get("ticket") + canvasNumber, "true");
									console.log("set persistence for user" + Session.get("ticket") + " canvas: " + canvasNumber);
								});
							}
						}

						createPersistSelf(5);
						createPersistSelf(4);
						createPersistSelf(3);
						createPersistSelf(2);
						createPersistSelf(1);


					</script>

					<div class="col-lg-10 animated fadeIn" id="col-sketch">
						{{#each solutions}}
							<div class="canvasContainer" data-CDIndex="{{canvasNumber}}">
								<canvas class="canvas-sketch" id="canvas-{{canvasNumber}}"></canvas>
								<div class="canvas-forms">
									<div class="row">
										<div class="col-md-12">
											<input id="name-{{canvasNumber}}" type="text"
											       placeholder="Name this solution"
											       class="form-control form-transparent form-name"
											       value="{{name}}">
										</div>
									</div>
									<div class="row">
										<div class="col-md-12">
											<textarea id="explain-{{canvasNumber}}" placeholder="Explain this solution"
											          class="explain form-transparent form-control form-description"
											          value="{{explain}}"></textarea>
										</div>
									</div>
								</div>
							</div>

							<script>

								$("#canvas-2").attr({"title": "This is another sketch canvas where you can design an alternative solution, you can make up to 5 alternative solutions"});
								$("#name-2").attr({"title": "This is where you explain and name the alternative solution"});

								// autosize of textarea's for the explaination fields
								$(function () {
									$(".explain").autosize()
								});

								// format new canvas element in HTML
								var idForNewCanvas = "canvas-" + {{canvasNumber}};
								var element = $("#" + idForNewCanvas);
								var canvasHeightShouldBe = 500;
								var canvasWidthShouldBe = $("#col-sketch").width();
								$(element).attr({"height": canvasHeightShouldBe, "width": canvasWidthShouldBe});

								// initialize Fabric canvas element
								var canvas = new fabric.Canvas(idForNewCanvas);
								canvas.CDIndex = {{canvasNumber}};

								// add references to this canvas
								canvases.push(canvas);
								canvasHistory[canvas.CDIndex] = {backStates: [], forwardStates: [], recording: true};

								var stopwatch = new Stopwatch();
								stopwatch.identifier = "{{canvasNumber}}";
								interactionStopwatches.push(stopwatch);


								// set canvas defaults
								canvas.isDrawingMode = true;
								canvas.freeDrawingBrush.width = 5;
								canvas.freeDrawingBrush.color = Session.get("currentColor");
								canvas.setBackgroundColor("white").renderAll();
							</script>

							{{#if state}}
								<script>
									canvas.loadFromJSON({{state}});
									canvas.renderAll();
									// code from save self
									var index = canvas.CDIndex;
									var recording = canvasHistory[index].recording;

									if (recording) {
										if (canvasHistory[index].backStates.length == 50) {
											canvasHistory[index].backStates.shift();
										}

										canvasHistory[index].forwardStates = [];
										canvasHistory[index].backStates.push(JSON.stringify(canvas));
									}
								</script>
							{{/if}}

							<script>

								// create connections to name and explain values
								var nameForThisCanvas = $("#name-" + {{canvasNumber}});
								var explainForThisCanvas = $("#explain-" + {{canvasNumber}});

								// set up sanitizer
								function sanitizeText(text) {
									return sanitizeHtml(text, {
										textFilter: function(text) {
											text = text.replace('$', 'dollar');
											text = text.replace('/', '&#x2F');
											text = text.replace('\'', '&#x27'); //TODO: this is not working well maybe remove
											return text;
										},
										allowedTags: [],
										allowedAttributes: []
									})
								}

								saveSelf = (function (canvas, name, explain, stopwatch) {
									return function () {
										var index = canvas.CDIndex;
										var recording = canvasHistory[index].recording;

										if (recording) {
											if (canvasHistory[index].backStates.length == 50) {
												canvasHistory[index].backStates.shift();
											}

											canvasHistory[index].forwardStates = [];
											canvasHistory[index].backStates.push(JSON.stringify(canvas));
										}

										// save solution
										Solutions.update(Session.get("objectId" + Session.get("ticket") + canvas.CDIndex), {
											$inc: {
												time: stopwatch.getElapsed().seconds
											},
											$set: {
												state: JSON.stringify(canvas),
												complexity: canvas._objects.length,
												dateUpdated: new Date(),
												name: sanitizeText(name.val()),
												explain: sanitizeText(explain.val())
											}
										}, function (error, number) {
											if (!error) {
												stopwatch.reset();
												// each stop watch reading is incrementing the value saved in the database, so we keep clearing
												// it here to add new chunks of time to what we have saved in the database
											}
										});

										// update workerTicketTimeInTool
										WorkerTickets.update(Session.get("ticket"), {
											$inc: {
												timeInTool: pageStopwatch.getElapsed().seconds
											}
										}, function (error, number) {
											if (!error) {
												pageStopwatch.reset();
											}
										})
									}
								})(canvas, nameForThisCanvas, explainForThisCanvas, stopwatch);

								// event hooks
								canvas.on('object:added', saveSelf);
								canvas.on('object:modified', saveSelf);
								canvas.on('object:removed', saveSelf);

								nameForThisCanvas.on("change", saveSelf);
								explainForThisCanvas.on("change", saveSelf);

								// initial save state
								saveSelf();

								// force focus on the first canvas when all are initialized (this runs every time, but haven't found a
								// lighter way to do this yet
								forceFocus(1);

							</script>
						{{/each}}
					</div>
				</div>
			</div>
		</div>
	</div>

	<div class="modal fade" id="finishModal" tabindex="-1" role="dialog" aria-labelledby="Finish confirmation"
	     aria-hidden="true">
		<div class="modal-dialog" role="document">
			<div class="modal-content">
				<div class="modal-header">
					<button type="button" class="close" data-dismiss="modal" aria-label="Close">
						<span aria-hidden="true">&times;</span>
						<span class="sr-only">Close</span>
					</button>
					<h4 class="modal-title">Are you sure you're ready to finish?</h4>
				</div>
				<div class="modal-body">
					{{#if shouldGenerateReviews}}
						<p class="modal-text">You are about to submit {{numberComplexEnough}} out of a possible 5 sketches.</p>

						<p><strong class="text-danger">Once you click "confirm", you will not have a chance to return and
							continue sketching your solutions.</strong></p>

						<p>As a reminder, your sketches will be reviewed using the following criteria:</p>

						<p>
						<ul class="small">
							<li>It is specified in English</li>
							<li>It has a proper name and textual explanation</li>
							<li>It has a sensible accompanying sketch that shows the alternative solution</li>
							<li>It is relevant to the decision point.</li>
						</ul>
						</p>

						<div class="row">
							<div class="col-xs-12">
								<h5 class="bottom-buffer-25">Sketches</h5>
								{{#each solutions}}
									{{#if canvasIsComplexEnough}}
										<div class="bottom-buffer-50">
											<img class="img-responsive img-rounded img-review" src="{{imageForCanvas canvasNumber}}">

											<div class="text-center">
												<p>{{name}}</p>
											</div>
										</div>
									{{/if}}
								{{/each}}
							</div>
						</div>
					{{/if}}
				</div>

				<div class="modal-footer">
					<button type="button" onclick="$('#finishModal').modal('hide');" class="btn btn-secondary"
					        data-dismiss="modal" id="finishCancel">Cancel
					</button>
					<button type="button" class="btn btn-success" id="finishConfirm">Confirm</button>
				</div>
			</div>
		</div>
	</div>


	<div class="modal fade" id="quitModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
		<div class="modal-dialog" role="document">
			<div class="modal-content">
				<div class="modal-header">
					<button type="button" class="close" data-dismiss="modal" aria-label="Close">
						<span aria-hidden="true">&times;</span>
						<span class="sr-only">Close</span>
					</button>
					<h4 class="modal-title">Are you sure you want to quit this HIT?</h4>
				</div>
				<div class="modal-body">
					<form id="quitForm" class="top-buffer-25">
						<label>Why are you quitting this task?</label>
						<!--- The task is to easy-->
						<!--- The task is to hard-->
						<!--- It is not clear to me what I need to do-->
						<!--- The tool does not work like I would expect-->
						<!--- Other, (provide textfield)-->
						<div class="radio">
							<label>
								<input type="radio" name="quitReason" value="too easy">
								The task is too easy
							</label>
						</div>
						<div class="radio">
							<label>
								<input type="radio" name="quitReason" value="too hard">
								The task is too hard
							</label>
						</div>
						<div class="radio">
							<label>
								<input type="radio" name="quitReason" value="not clear">
								It is not clear to me what I need to do
							</label>
						</div>
						<div class="radio">
							<label>
								<input type="radio" name="quitReason" value="tool doesn't work">
								The tool does not work like I would expect
							</label>
						</div>
						<div class="radio">
							<label>
								<input type="radio" name="quitReason" value="Other">
								Other (explained below)
							</label>
						</div>
						<fieldset class="form-group top-buffer-50">
							<label for="quitText">Do you have any feedback to improve this HIT?</label>
							<textarea class="form-control" id="quitText" rows="3"></textarea>
						</fieldset>
						<div class="modal-footer">
							<button type="button" class="btn btn-secondary" data-dismiss="modal">Cancel</button>
							<button type="submit" class="btn btn-danger disabled" disabled="true" id="quitSubmit">Quit this HIT
							</button>
						</div>
					</form>
				</div>
			</div>
		</div>
	</div>

	<style>
		.container-tool {
			margin-top: 60px;
		}

		.canvasContainer {
			opacity: 0.4;
			transition: opacity .13s ease-out;
		}

		.canvasContainer.focusedCanvas {
			opacity: 1;
		}

		canvas.canvas-sketch {
			display: block;
			box-shadow: 0px 16px 32px 0px rgba(0, 0, 0, 0.04);
			border-radius: 5px;
		}

		.form-transparent {
			background-color: transparent;
			border: none;
			outline: none;
		}

		.canvas-forms {
			margin-top: 25px;
		}

		.form-name {
			font-size: 20px;
		}

		.form-description {
			font-size: 15px;
			line-height: 20px;
			height: 80px;
			resize: none;
		}

		.img-review {
			display: block;
			box-shadow: 0px 16px 32px 0px rgba(0, 0, 0, 0.09);
			border-radius: 5px;
			margin-bottom: 20px;
		}
	</style>
</template>

<template name="decisionPointInformationPanel">
	<div class="row">
		<div class="col-md-12 col-lg-10 col-lg-offset-1">
			<div class="row">
				<div class="col-xs-12" data-intro="This is your decision point. Read it carefully and try to think of different solutions to solve it." data-position="right">
					<h4>{{name}}<br></h4>
					<p>{{description}}</p>
					<p>
					<span class="text-muted">
						<strong>REQUIREMENTS</strong>
					</span>
					</p>

					<p>{{requirements}}</p>
				</div>
			</div>
			<div class="row top-buffer-100 right-buffer-10">
				<div class="pull-left">
                    <a data-toggle="modal" data-target="#finishModal" id="finishRequest" class="btn btn-success btn-continue" data-position="right" data-step="5" data-intro="When you are done with designing your solutions, click here to review them one more time and to submit them.">
                   REVIEW AND FINISH</a>
				</div>
            </div>
            <div class="row top-buffer-100 right-buffer-10">
				<div class="pull-left">
                    <button id="quitRequest" class="btn btn-danger btn-continue" data-toggle="modal" data-position="right" data-target="#quitModal" data-step="4" data-intro="Please click here if you want to quit the task">QUIT</button>
				</div>
			</div>
		</div>
	</div>

	<script>
        //start intro
        introJs().setOptions({
            "scrollToElement": true,
            "showStepNumbers": false,
        }).start();


        //Google analytics
        $("#finishRequest").click(function () {
            ga('send', {
                hitType: 'event',
                eventCategory: 'Button',
                eventAction: 'Review and Finish',
                eventLabel: Session.get("ticket")
            });
        });

        $("#quitRequest").click(function () {
            ga('send', {
                hitType: 'event',
                eventCategory: 'Button',
                eventAction: 'Quit',
                eventLabel: Session.get("ticket")
            });
        });

        //auto resize of textarea's
		$(function () {
			$('textarea').autosize()
		});

	</script>


</template>